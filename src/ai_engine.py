"""
Advanced AI Engine for Leadership Quality Tool
Transforms the system from a basic dashboard to an intelligent AI assistant
"""

import json
import re
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import numpy as np
from dataclasses import dataclass
from llm import chat
from jira_client import JiraClient

@dataclass
class AIInsight:
    """Structured insight generated by AI"""
    type: str  # 'trend', 'anomaly', 'recommendation', 'prediction', 'analysis'
    title: str
    description: str
    confidence: float  # 0-1
    data_points: List[Dict[str, Any]]
    actionable: bool
    priority: str  # 'high', 'medium', 'low'
    category: str  # 'velocity', 'quality', 'team', 'project', 'sprint'

class AdvancedAIEngine:
    """Advanced AI engine that provides intelligent analysis and insights"""
    
    def __init__(self, jira_client: Optional[JiraClient] = None):
        self.jira_client = jira_client
        self.conversation_context = []
        self.learned_patterns = {}
        self.user_preferences = {}
        
    def analyze_query_intent(self, query: str) -> Dict[str, Any]:
        """Use AI to understand user intent beyond keyword matching"""
        
        intent_prompt = f"""
        You are an AI assistant for a Leadership Quality Tool that helps leaders understand project management data from Jira and Confluence.
        
        Analyze this user query from a leadership perspective and determine the intent, context, and required data sources.
        
        Query: "{query}"
        
        As a leadership assistant, determine:
        1. Primary intent (data_retrieval, analysis, prediction, recommendation, comparison, trend_analysis, team_performance, project_status, sprint_health, quality_metrics)
        2. Data sources needed (jira_tickets, jira_analytics, sprint_data, team_data, project_data, confluence_docs)
        3. Time scope (current, historical, future, specific_period)
        4. Entities mentioned (people, projects, tickets, sprints, teams)
        5. Analysis type (descriptive, diagnostic, predictive, prescriptive)
        6. Complexity level (simple, moderate, complex)
        7. Expected output format (summary, detailed_report, visualization, recommendation)
        8. Leadership context (team_performance, project_health, quality_assessment, resource_allocation, risk_management)
        
        IMPORTANT: Respond ONLY with valid JSON, no markdown formatting, no code blocks. Example:
        {{"primary_intent": "team_performance", "data_sources": ["jira_tickets"], "time_scope": "current", "entities": [], "analysis_type": "descriptive", "complexity_level": "simple", "expected_output_format": "summary", "leadership_context": "team_performance"}}
        """
        
        try:
            response = chat([{"role": "user", "content": intent_prompt}])
            # Clean up response - remove markdown code blocks if present
            if response.startswith('```json'):
                response = response[7:]  # Remove ```json
            if response.endswith('```'):
                response = response[:-3]  # Remove ```
            response = response.strip()
            
            # Parse JSON response
            import json
            return json.loads(response)
        except Exception as e:
            print(f"❌ AI Intent Analysis failed: {e}")
            # Fallback to enhanced analysis
            return self._enhanced_fallback_intent_analysis(query)
    
    def _enhanced_fallback_intent_analysis(self, query: str) -> Dict[str, Any]:
        """Enhanced fallback intent analysis with leadership context"""
        query_lower = query.lower()
        
        # Enhanced pattern matching with leadership context
        intent = "data_retrieval"
        leadership_context = "team_performance"
        
        # Leadership-specific intent detection
        if any(word in query_lower for word in ['predict', 'forecast', 'trend', 'future', 'velocity', 'capacity']):
            intent = "prediction"
            leadership_context = "resource_allocation"
        elif any(word in query_lower for word in ['recommend', 'suggest', 'should', 'advice', 'improve', 'optimize']):
            intent = "recommendation"
            leadership_context = "process_improvement"
        elif any(word in query_lower for word in ['compare', 'vs', 'versus', 'difference', 'benchmark']):
            intent = "comparison"
            leadership_context = "performance_assessment"
        elif any(word in query_lower for word in ['analyze', 'analysis', 'insight', 'pattern', 'health', 'status']):
            intent = "analysis"
            leadership_context = "project_health"
        elif any(word in query_lower for word in ['team', 'member', 'assignee', 'workload', 'capacity']):
            intent = "team_performance"
            leadership_context = "team_performance"
        elif any(word in query_lower for word in ['sprint', 'iteration', 'velocity', 'burndown']):
            intent = "sprint_health"
            leadership_context = "sprint_health"
        elif any(word in query_lower for word in ['quality', 'defect', 'bug', 'testing', 'review']):
            intent = "quality_metrics"
            leadership_context = "quality_assessment"
        elif any(word in query_lower for word in ['project', 'initiative', 'program', 'portfolio']):
            intent = "project_status"
            leadership_context = "project_health"
            
        return {
            "primary_intent": intent,
            "data_sources": ["jira_tickets", "jira_analytics"],
            "time_scope": "current",
            "entities": [],
            "analysis_type": "descriptive",
            "complexity_level": "simple",
            "expected_output_format": "summary",
            "leadership_context": leadership_context
        }
    
    def generate_intelligent_response(self, query: str, jira_data: Dict[str, Any] = None) -> str:
        """Generate intelligent AI response based on query and data"""
        
        # Analyze intent
        intent = self.analyze_query_intent(query)
        
        # Build context-aware prompt with conversation history
        context_prompt = self._build_context_prompt(query, intent, jira_data)
        
        # Generate response using AI
        try:
            response = chat([{"role": "user", "content": context_prompt}])
            enhanced_response = self._enhance_response_with_insights(response, jira_data, intent)
            
            # Store in conversation context for future reference
            self.conversation_context.append({
                'query': query,
                'response': enhanced_response,
                'timestamp': datetime.now().isoformat(),
                'entities': self._extract_entities_from_query(query)
            })
            
            # Keep only last 10 interactions
            if len(self.conversation_context) > 10:
                self.conversation_context = self.conversation_context[-10:]
            
            return enhanced_response
        except Exception as e:
            print(f"❌ AI Engine: Response generation failed: {e}")
            return f"I encountered an error while processing your request: {str(e)}"
    
    def _build_context_prompt(self, query: str, intent: Dict[str, Any], jira_data: Dict[str, Any] = None) -> str:
        """Build data-focused context prompt for AI"""
        
        leadership_context = intent.get('leadership_context', 'team_performance')
        primary_intent = intent.get('primary_intent', 'data_retrieval')
        
        prompt = f"""
        You are a JIRA data assistant for TAO Digital. Your job is to provide direct, specific answers with concrete data from JIRA tickets.
        
        CRITICAL: Answer ONLY with specific JIRA data. Do NOT provide generic leadership advice, strategic insights, or recommendations.
        
        USER QUESTION: "{query}"
        QUERY INTENT: {primary_intent}
        DATA FOCUS: {leadership_context}
        
        CONTEXT:
        - Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        - Conversation History: {len(self.conversation_context)} previous interactions
        """
        
        # Add conversation context for references
        if self.conversation_context:
            recent_context = self.conversation_context[-3:]  # Last 3 interactions
            prompt += f"""
            
            CONVERSATION CONTEXT:
            """
            for i, ctx in enumerate(recent_context, 1):
                prompt += f"""
            {i}. Query: "{ctx['query']}"
               Entities: {ctx.get('entities', {})}
               """
            
            prompt += """
            
            CONTEXTUAL UNDERSTANDING:
            - If user refers to "this ticket", check recent context for ticket references
            - If user refers to "this assignee", check recent context for assignee references
            - Use conversation history to provide more specific and relevant responses
            """
        
        if jira_data:
            prompt += f"""
            
            AVAILABLE DATA:
            {json.dumps(jira_data, indent=2)[:2000]}
            """
        
        # Add data-specific guidance based on context
        if leadership_context == "team_performance":
            prompt += """
            
            TEAM PERFORMANCE DATA FOCUS:
            - Provide specific ticket counts per assignee
            - Include exact status breakdowns (Done, In Progress, To Do)
            - Mention specific ticket numbers and names
            - Skip analysis or recommendations
            """
        elif leadership_context == "project_health":
            prompt += """
            
            PROJECT HEALTH DATA FOCUS:
            - Provide specific ticket counts and statuses
            - Include exact dates and ticket numbers
            - Mention specific blockers with ticket IDs
            - Skip analysis or recommendations
            """
        elif leadership_context == "quality_assessment":
            prompt += """
            
            QUALITY ASSESSMENT DATA FOCUS:
            - Provide specific bug counts and ticket numbers
            - Include exact statuses and assignees
            - Mention specific ticket IDs and names
            - Skip analysis or recommendations
            """
        elif leadership_context == "sprint_health":
            prompt += """
            
            SPRINT HEALTH DATA FOCUS:
            - Provide specific ticket counts and statuses
            - Include exact sprint dates and ticket numbers
            - Mention specific ticket IDs and names
            - Skip analysis or recommendations
            """
        
        prompt += """
        
RESPONSE GUIDELINES:
1. Answer the specific question asked - be direct and concise
2. Always include specific ticket numbers (e.g., PROJ-412, PROJ-405)
3. Include exact counts, names, and dates
4. Provide concrete examples with ticket IDs
5. Skip interpretation, analysis, or recommendations
6. Focus on factual data only
7. NEVER use placeholder text like "[Insert" or "[Provide" - use realistic estimates or say "Data not available"
8. Maintain context from previous questions when references like "this ticket" or "this assignee" are used
9. Focus on immediate relevance - what specific data does the user need right now?
        
        RESPONSE FORMAT:
        • Direct Answer: [Specific answer with ticket numbers and data]
        • Specific Data: [Exact counts, names, dates, ticket IDs]
        • Examples: [Concrete examples with ticket numbers]
        
        SPECIAL CAPABILITIES:
        - Generate jQuery/JavaScript code for Jira API calls when requested
        - Suggest name corrections and search variations for fuzzy matching
        - Provide specific data even with partial information
        - Connect technical metrics to specific ticket data
        - Maintain conversation context for references like "this ticket" or "this assignee"
        
        RESPONSE STYLE:
        - Professional but conversational
        - Data-driven with specific ticket information
        - Focus on concrete facts and ticket numbers
        - Use bullet points for clarity and readability
        - Avoid technical jargon unless necessary
        - NEVER use placeholder text - provide realistic data or say "Data not available"
        """
        
        return prompt
    
    def _enhance_response_with_insights(self, base_response: str, jira_data: Dict[str, Any], intent: Dict[str, Any]) -> str:
        """Enhance response with specific data context"""
        
        # Return the base response without adding leadership analysis
        return base_response.strip()
    
    def _extract_entities_from_query(self, query: str) -> Dict[str, Any]:
        """Extract entities from query for context tracking"""
        entities = {}
        
        # Extract ticket references
        import re
        ticket_match = re.search(r'([A-Z]+-\d+)', query)
        if ticket_match:
            entities['ticket'] = ticket_match.group(1)
        
        # Extract assignee references
        assignee_patterns = [
            'ajith', 'kumar', 'ashwin', 'thyagarajan', 'john', 'jane', 'mike', 'sarah', 'david', 'lisa'
        ]
        query_lower = query.lower()
        for pattern in assignee_patterns:
            if pattern in query_lower:
                entities['assignee'] = pattern.title()
                break
        
        # Extract project references
        project_patterns = ['ccm', 'ces', 'gtms', 'ti']
        for pattern in project_patterns:
            if pattern in query_lower:
                entities['project'] = pattern.upper()
                break
        
        return entities
    
    def _generate_data_insights(self, jira_data: Dict[str, Any], intent: Dict[str, Any]) -> str:
        """Generate data-driven insights using AI"""
        
        if not jira_data:
            return ""
        
        insight_prompt = f"""
        Analyze this Jira data and provide key insights:
        
        Data: {json.dumps(jira_data, indent=2)[:1500]}
        
        Focus on:
        1. Performance trends and patterns
        2. Potential issues or risks
        3. Opportunities for improvement
        4. Team productivity indicators
        5. Quality metrics
        
        Provide 3-5 specific, actionable insights in bullet points.
        """
        
        try:
            insights = chat([{"role": "user", "content": insight_prompt}])
            return insights
        except Exception as e:
            return f"Unable to generate insights: {str(e)}"
    
    def _generate_contextual_recommendations(self, intent: Dict[str, Any], jira_data: Dict[str, Any]) -> str:
        """Generate contextual recommendations based on intent and data"""
        
        recommendation_prompt = f"""
        Based on the user's intent ({intent.get('primary_intent')}) and available data, provide 2-3 specific, actionable recommendations for leadership.
        
        Focus on:
        - Process improvements
        - Resource allocation
        - Risk mitigation
        - Performance optimization
        
        Make recommendations specific and measurable.
        """
        
        try:
            recommendations = chat([{"role": "user", "content": recommendation_prompt}])
            return recommendations
        except Exception as e:
            return f"Unable to generate recommendations: {str(e)}"
    
    def generate_predictive_analysis(self, query: str, historical_data: Dict[str, Any]) -> str:
        """Generate predictive analysis using AI"""
        
        prediction_prompt = f"""
        As a data science expert, analyze this historical Jira data and make predictions:
        
        Query: "{query}"
        Historical Data: {json.dumps(historical_data, indent=2)[:2000]}
        
        Provide:
        1. Trend analysis and patterns
        2. Predictive forecasts (next 2-4 weeks)
        3. Confidence intervals
        4. Risk factors and assumptions
        5. Recommended actions based on predictions
        
        Use professional data science language and include specific metrics.
        """
        
        try:
            prediction = chat([{"role": "user", "content": prediction_prompt}])
            return prediction
        except Exception as e:
            return f"Unable to generate prediction: {str(e)}"
    
    def detect_anomalies(self, jira_data: Dict[str, Any]) -> List[AIInsight]:
        """Detect anomalies and generate insights"""
        
        anomalies = []
        
        if not jira_data or 'analytics' not in jira_data:
            return anomalies
        
        analytics = jira_data['analytics']
        projects = analytics.get('projects', {})
        
        # Analyze defect ratios
        for project_key, project_data in projects.items():
            stories = project_data.get('stories', 0)
            defects = project_data.get('defects', 0)
            
            if stories > 0:
                defect_ratio = (defects / stories) * 100
                
                if defect_ratio > 25:  # High defect ratio
                    anomalies.append(AIInsight(
                        type='anomaly',
                        title=f'High Defect Ratio in {project_key}',
                        description=f'Defect ratio of {defect_ratio:.1f}% exceeds normal threshold',
                        confidence=0.8,
                        data_points=[{'project': project_key, 'defect_ratio': defect_ratio}],
                        actionable=True,
                        priority='high',
                        category='quality'
                    ))
        
        return anomalies
    
    def generate_automated_insights(self, jira_data: Dict[str, Any]) -> List[AIInsight]:
        """Generate automated insights from data"""
        
        insights = []
        
        if not jira_data or 'analytics' not in jira_data:
            return insights
        
        analytics = jira_data['analytics']
        summary = analytics.get('summary', {})
        
        # Team workload analysis
        total_issues = summary.get('total_issues', 0)
        total_assignees = summary.get('total_assignees', 0)
        
        if total_assignees > 0:
            avg_workload = total_issues / total_assignees
            
            if avg_workload > 15:
                insights.append(AIInsight(
                    type='recommendation',
                    title='High Team Workload Detected',
                    description=f'Average workload of {avg_workload:.1f} issues per person',
                    confidence=0.9,
                    data_points=[{'avg_workload': avg_workload, 'total_issues': total_issues}],
                    actionable=True,
                    priority='medium',
                    category='team'
                ))
        
        return insights
    
    def learn_from_interaction(self, query: str, response: str, user_feedback: Optional[str] = None):
        """Learn from user interactions to improve future responses"""
        
        # Store interaction for learning
        interaction = {
            'query': query,
            'response': response,
            'timestamp': datetime.now().isoformat(),
            'feedback': user_feedback
        }
        
        self.conversation_context.append(interaction)
        
        # Keep only last 50 interactions
        if len(self.conversation_context) > 50:
            self.conversation_context = self.conversation_context[-50:]
        
        # Extract patterns for learning
        self._extract_learning_patterns(query, response)
    
    def _extract_learning_patterns(self, query: str, response: str):
        """Extract patterns from interactions for learning"""
        
        # Simple pattern extraction (can be enhanced with ML)
        query_words = query.lower().split()
        
        for word in query_words:
            if word not in self.learned_patterns:
                self.learned_patterns[word] = {'count': 0, 'contexts': []}
            
            self.learned_patterns[word]['count'] += 1
            self.learned_patterns[word]['contexts'].append({
                'query': query,
                'response_type': 'success' if len(response) > 50 else 'short'
            })
    
    def get_conversation_summary(self) -> str:
        """Generate a summary of the conversation context"""
        
        if not self.conversation_context:
            return "No previous interactions."
        
        recent_interactions = self.conversation_context[-10:]  # Last 10 interactions
        
        summary_prompt = f"""
        Summarize these recent user interactions to understand context and preferences:
        
        {json.dumps(recent_interactions, indent=2)}
        
        Provide a brief summary of:
        1. User's main interests and questions
        2. Preferred response styles
        3. Common patterns in queries
        4. Areas for improvement
        """
        
        try:
            summary = chat([{"role": "user", "content": summary_prompt}])
            return summary
        except Exception as e:
            return f"Unable to generate summary: {str(e)}"
